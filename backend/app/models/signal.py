"""Trading Signal models"""

from datetime import datetime
from enum import Enum
from typing import List, Optional, Tuple, Dict, Any
from dataclasses import dataclass, field
from uuid import uuid4


class SignalStatus(Enum):
    """Status of a trading signal"""
    ACTIVE = "active"
    TRIGGERED = "triggered"
    HIT_TP1 = "hit_tp1"
    HIT_TP2 = "hit_tp2"
    HIT_TP3 = "hit_tp3"
    HIT_SL = "hit_sl"
    EXPIRED = "expired"
    CANCELLED = "cancelled"


class TradingDirection(Enum):
    """Trading direction"""
    BUY = "BUY"
    SELL = "SELL"
    WAIT = "WAIT"


class Timeframe(Enum):
    """Trading timeframes"""
    M1 = "M1"
    M5 = "M5"
    M15 = "M15"
    M30 = "M30"
    H1 = "H1"
    H4 = "H4"
    D1 = "D1"
    W1 = "W1"
    MN = "MN"


@dataclass
class KeyLevel:
    """A key price level identified by analysis"""
    level_type: str  # ob, fvg, liquidity, swing, etc.
    price: float
    high: Optional[float] = None
    low: Optional[float] = None
    timestamp: Optional[datetime] = None
    strength: float = 0.0  # 0-1, how significant is this level
    mitigated: bool = False


@dataclass
class SignalFactor:
    """A factor contributing to the signal"""
    name: str
    description: str
    weight: float  # 0-1, contribution to signal
    met: bool
    details: Optional[str] = None


@dataclass
class Signal:
    """
    A complete trading signal generated by the system

    This is the main output that users will receive and act upon.
    """

    id: str = field(default_factory=lambda: str(uuid4()))
    symbol: str = ""
    timeframe: Timeframe = Timeframe.H1
    direction: TradingDirection = TradingDirection.WAIT

    # Confidence and scoring
    confidence: float = 0.0  # 0-1
    signal_score: int = 0  # 0-100

    # Entry details
    current_price: float = 0.0
    entry_zone: Tuple[float, float] = (0.0, 0.0)
    entry_price: Optional[float] = None  # Exact entry if triggered

    # Risk management
    stop_loss: float = 0.0
    take_profit_1: float = 0.0
    take_profit_2: Optional[float] = None
    take_profit_3: Optional[float] = None
    risk_reward_ratio: float = 0.0

    # Analysis details
    factors: List[SignalFactor] = field(default_factory=list)
    key_levels: List[KeyLevel] = field(default_factory=list)
    analysis_text: str = ""

    # Multi-timeframe context
    mtf_bias: str = ""  # bullish, bearish, neutral
    htf_structure: str = ""  # Higher timeframe market structure
    ltf_confirmation: bool = False

    # Smart Money specific
    order_blocks: List[Dict[str, Any]] = field(default_factory=list)
    fair_value_gaps: List[Dict[str, Any]] = field(default_factory=list)
    liquidity_levels: List[Dict[str, Any]] = field(default_factory=list)
    premium_discount_zone: str = ""  # premium, discount, equilibrium
    kill_zone_active: bool = False
    kill_zone_name: Optional[str] = None

    # Charts
    annotated_chart_url: Optional[str] = None
    chart_data: Optional[Dict[str, Any]] = None

    # Status and tracking
    status: SignalStatus = SignalStatus.ACTIVE
    triggered_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    actual_result: Optional[float] = None  # PnL in pips/points

    # Validity
    created_at: datetime = field(default_factory=datetime.utcnow)
    valid_until: datetime = field(default_factory=datetime.utcnow)

    # Source tracking
    concept_ids_used: List[str] = field(default_factory=list)
    rule_ids_used: List[str] = field(default_factory=list)

    # ML Knowledge tracking
    ml_patterns_detected: List[str] = field(default_factory=list)  # Patterns ML found
    ml_patterns_not_learned: List[str] = field(default_factory=list)  # Patterns ML can't detect yet
    ml_confidence_scores: Dict[str, float] = field(default_factory=dict)  # Confidence per pattern
    ml_knowledge_status: str = ""  # Summary of ML knowledge state

    def calculate_risk_reward(self) -> float:
        """Calculate risk:reward ratio"""
        if self.direction == TradingDirection.WAIT:
            return 0.0

        entry_mid = (self.entry_zone[0] + self.entry_zone[1]) / 2
        risk = abs(entry_mid - self.stop_loss)

        if risk == 0:
            return 0.0

        reward = abs(self.take_profit_1 - entry_mid)
        return round(reward / risk, 2)

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "symbol": self.symbol,
            "timeframe": self.timeframe.value,
            "direction": self.direction.value,
            "confidence": self.confidence,
            "signal_score": self.signal_score,
            "current_price": self.current_price,
            "entry_zone": self.entry_zone,
            "stop_loss": self.stop_loss,
            "take_profit_1": self.take_profit_1,
            "take_profit_2": self.take_profit_2,
            "take_profit_3": self.take_profit_3,
            "risk_reward_ratio": self.risk_reward_ratio,
            "factors": [
                {"name": f.name, "met": f.met, "weight": f.weight}
                for f in self.factors
            ],
            "mtf_bias": self.mtf_bias,
            "premium_discount_zone": self.premium_discount_zone,
            "kill_zone_active": self.kill_zone_active,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "valid_until": self.valid_until.isoformat(),
            "analysis_text": self.analysis_text,
            # ML Knowledge info
            "ml_patterns_detected": self.ml_patterns_detected,
            "ml_patterns_not_learned": self.ml_patterns_not_learned,
            "ml_confidence_scores": self.ml_confidence_scores,
            "ml_knowledge_status": self.ml_knowledge_status,
        }

    def to_notification_message(self) -> str:
        """Format signal for notification"""
        emoji = "üü¢" if self.direction == TradingDirection.BUY else "üî¥" if self.direction == TradingDirection.SELL else "‚ö™"

        factors_text = "\n".join([f"‚Ä¢ {f.name}" for f in self.factors if f.met])

        return f"""
{emoji} *Smart Money SIGNAL ALERT* {emoji}

*{self.symbol}* | {self.timeframe.value}
Direction: *{self.direction.value}*
Confidence: {self.confidence:.0%}

üìä *Levels:*
Entry Zone: {self.entry_zone[0]:.5f} - {self.entry_zone[1]:.5f}
Stop Loss: {self.stop_loss:.5f}
Take Profit 1: {self.take_profit_1:.5f}
Take Profit 2: {self.take_profit_2:.5f if self.take_profit_2 else 'N/A'}
Risk:Reward: 1:{self.risk_reward_ratio:.1f}

üìã *Analysis:*
{factors_text}

MTF Bias: {self.mtf_bias.title()}
Zone: {self.premium_discount_zone.title()}
Kill Zone: {'‚úÖ ' + self.kill_zone_name if self.kill_zone_active else '‚ùå'}

‚è∞ Valid until: {self.valid_until.strftime('%Y-%m-%d %H:%M')} UTC
"""


@dataclass
class SignalPerformance:
    """Track signal performance over time"""

    id: str = field(default_factory=lambda: str(uuid4()))
    signal_id: str = ""

    # Outcome
    outcome: str = ""  # win, loss, breakeven, expired
    pnl_pips: float = 0.0
    pnl_percentage: float = 0.0

    # Execution details
    actual_entry: Optional[float] = None
    actual_exit: Optional[float] = None
    max_favorable_excursion: float = 0.0  # Best price reached
    max_adverse_excursion: float = 0.0  # Worst price reached

    # Timing
    time_to_trigger: Optional[float] = None  # seconds
    time_in_trade: Optional[float] = None  # seconds

    # Analysis
    notes: str = ""

    created_at: datetime = field(default_factory=datetime.utcnow)
